class Vector:
  val x: float
  val y: float
  val z: float

  def times(self, k: float) -> Vector:
    Vector(k * self.x, k * self.y, k * self.z)

  def minus(self, v2: Vector) -> Vector:
    Vector(self.x - v2.x, self.y - v2.y, self.z - v2.z)

  def plus(self, v2: Vector) -> Vector:
    Vector(self.x + v2.x, self.y + v2.y, self.z + v2.z)

  def dot(self, v2: Vector) -> float:
    self.x * v2.x + self.y * v2.y + self.z * v2.z

  def mag(self) -> float:
    sqrt(self.x * self.x + self.y * self.y + self.z * self.z)

  def norm(self) -> Vector:
    self.times(1/self.mag())

  def cross(self, v2: Vector) -> Vector:
    Vector(self.y * v2.z - self.z * v2.y, self.z * v2.x - self.x * v2.z, self.x * v2.y - self.y * v2.x)

def toByte(n: float) -> float:
 if n <= 0:
   0
 elif n >= 1:
   255
 else:
   int(n * 255)



class Color:
  static val BLACK = Color(0,0,0)
  static val WHITE = Color(1,1,1)
  static val GREY = Color(0.5, 0.5, 0.5)

  val r: float
  val g: float
  val b: float

  def scale(self, k: float) -> Color:
    Color(k * self.r, k * self.g, k * self.b)

  def plus(self, c2: Color) -> Color:
    Color(self.r + c2.r, self.g + c2.g, self.b + c2.b)

  def times(self, c2: Color) -> Color:
    Color(self.r * c2.r, self.g * c2.g, self.b * c2.b)

  def toDrawingColor(self) -> float:
    255*256*65536 + toByte(self.r) * 65536 + toByte(self.g) * 256 + toByte(self.b)



class Camera:
  val pos: Vector
  val forward: Vector
  val right: Vector
  val up: Vector

  def lookingAt(pos: Vector, lookAt: Vector) -> Camera:
    val down = Vector(0, -1, 0)
    val forward = lookAt.minus(pos).norm()
    val right = forward.cross(down).norm().times(1.5)
    val up = forward.cross(right).norm().times(1.5)
    Camera(pos, forward, right, up)


class Ray:
  val start: Vector
  val dir: Vector


class Intersection:
  val thing: Thing
  val ray: Ray
  val dist: float


trait Surface:
  def roughness(self) -> float
  def diffuse(self, pos: Vector) -> Color
  def specular(self, pos: Vector) ->  Color
  def reflect(self, pos: Vector) -> float


trait Thing:
  def surface(self) -> Surface
  def normal(self, pos: Vector) -> Vector
  def intersect(self, ray: Ray) -> Intersection

class Light:
  val pos: Vector
  val color: Color

class Scene:
  val things: List[Thing]
  val lights: List[Light]
  val camera: Camera
  val background: Color

class Sphere:
  val center: Vector
  val radius2: float
  val surface: Surface

  def create(center: Vector, radius: float, surface: Surface) -> Sphere:
    Sphere(center, radius * radius, surface)


impl Thing for Sphere:

 def surface(self) -> Surface:
   self.surface

 def normal(self, pos: Vector) -> Vector:
   pos.minus(self.center).norm()

 def intersect(self, r: Ray) -> Intersection:
   val eo = self.center.minus(r.start)
   val v = eo.dot(r.dir)
   var dist = 1/0
   if v >= 0 :
     val disc = self.radius2 - (eo.dot(eo) - v * v)
     if disc >= 0 :
       dist = v - sqrt(disc)

  Intersection(self, r, dist)


class Plane:
  val norm: Vector
  val offset: float
  val surface: Surface


impl Thing for Plane:
  def surface(self) -> Surface:
    self.surface

  def normal(self, pos: Vector) -> Vector:
    self.norm

  def intersect(self, r: Ray) -> Intersection:
    val denom = self.norm.dot(r.dir)
    var dist = 1/0
    if denom <= 0:
      dist = (self.norm.dot(r.start) + self.offset) / (-denom)

    Intersection(self, r, dist)


class Shiny:

impl Surface for Shiny:
  def roughness(self) -> float:
    250

  def diffuse(self, pos: Vector) -> Color:
    Color.WHITE

  def specular(self, pos: Vector) -> Color:
    Color.GREY

  def reflect(self, pos: Vector) -> float:
    0.7

class Checkerboard:

impl Surface for Checkerboard:
  def roughness(self) -> float:
    150

  def diffuse(self, pos: Vector) -> Color:
    if (100000 + math.floor(pos.z) + math.floor(pos.x)) % 2 != 0 :
      Color.WHITE
    else:
      Color.BLACK

 def specular(self, pos: Vector) -> Color:
   Color.WHITE

 def reflect(self, pos: Vector) -> float:
   if (1000 + int(pos.z) + int(pos.x)) % 2 != 0 :
     0.1
   else:
     0.7


class RayTracer:
  val maxDepth = 5
  val defaultColor = Color.BLACK

  def intersections(self, r: Ray, s: Scene) -> Intersection:
    var closest = s.things[0].intersect(r)
    for i in range(1, len(s.things)):
      val inter = s.things[i].intersect(r)
      if inter.dist < closest.dist :
        closest = inter

    closest

  def testRay(self, r: Ray, s: Scene) -> float:
    self.intersections(r, s).dist

  def traceRay(self, r: Ray, s: Scene, depth: float) -> Color:
    val isect = self.intersections(r, s)
    if isect.dist == 1/0 :
      s.background
    else:
      self.shade(isect, s, depth)

  def shade(self, isect: Intersection, s: Scene, depth: float) -> Color:
    val d = isect.ray.dir
    val pos = d.times(isect.dist).plus(isect.ray.start)
    val normal = isect.thing.normal(pos)
    val reflectDir = d.minus(normal.times(2 * normal.dot(d)))
    val naturalColor = s.background.plus(self.getNaturalColor(isect.thing, pos, normal, reflectDir, s))
    var reflectedColor = Color.GREY
    if depth < self.maxDepth :
      reflectedColor = self.getReflectionColor(isect.thing, pos, normal, reflectDir, s, depth)

    naturalColor.plus(reflectedColor)

  def getReflectionColor(self, t: Thing, pos: Vector, normal: Vector, rd: Vector, s: Scene, depth: float) -> Color:
    self.traceRay(Ray(pos, rd), s, depth + 1).scale(t.surface().reflect(pos))

  def addLight(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene, col: Color, l: Light) -> Color:
    val ldis = l.pos.minus(pos)
    val livec = ldis.norm()
    val nearIsect = self.testRay(Ray(pos, livec), s)
    val isInShadow = (nearIsect <= ldis.mag())
    if isInShadow :
      return col

    val illum = livec.dot(norm)
    var lcolor = self.defaultColor
    if illum > 0 :
      lcolor = l.color.scale(illum)

    val specular = livec.dot(rd.norm())
    var scolor = self.defaultColor
    if specular > 0 :
      scolor = l.color.scale(specular ^ t.surface().roughness())

    val surf = t.surface()
    val diff = surf.diffuse(pos)
    col.plus(lcolor.times(diff)).plus(scolor.times(t.surface().specular(pos)))

  def getNaturalColor(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene) -> Color:
    var col = self.defaultColor
    for l in s.lights:
      col = self.addLight(t, pos, norm, rd, s, col, l)

    col

  def getPoint(self, x: float, y: float, cam: Camera) -> Vector:
    cam.forward.plus(cam.right.times(x / 200)).plus(cam.up.times(y / 200)).norm()

  def render(self, s: Scene, p: Pen, screenWidth: float, screenHeight: float):
    p.strokeColor = 0
    for y in range(screenHeight):
      for x in range(-screenWidth / 2, screenWidth / 2):
        var yy = math.floor(y / 2)
        if y % 2 == 0:
          yy = -yy

        val color = self.traceRay(Ray(s.camera.pos, self.getPoint(x, yy, s.camera)), s, 0)
        p.fillColor = color.toDrawingColor()
        p.rect(x, yy, 1.5, 1.5)


val defaultThings = [Plane(Vector(0,1,0), 0, Checkerboard()), Sphere(Vector(0,1,-0.25), 1, Shiny()), Sphere(Vector(-1,0.5,1.5),0.5, Shiny())]
val defaultLights = [Light(Vector(-2,2.5,0), Color(0.49,0.07,0.07)), Light(Vector(1.5,2.5,1.5), Color(0.07,0.07,0.49)), Light(Vector(1.5,2.5,-1.5), Color(0.07,0.49,0.071)), Light(Vector(0,3.5,0), Color(0.21,0.21,0.35))]
val defaultCamera = Camera.lookingAt(Vector(3,2,4), Vector(-1,0.5,0))
val defaultScene = Scene(Color.BLACK, defaultThings, defaultLights, defaultCamera)

def main():
  val rayTracer = RayTracer()
  rayTracer.render(defaultScene, pen, 320, 320)
