class Vector:
  let x: float
  let y: float
  let z: float

  def times(self, k: float) -> Vector:
    Vector(k * self.x, k * self.y, k * self.z)

  def minus(self, v2: Vector) -> Vector:
    Vector(self.x - v2.x, self.y - v2.y, self.z - v2.z)

  def plus(self, v2: Vector) -> Vector:
    Vector(self.x + v2.x, self.y + v2.y, self.z + v2.z)

  def dot(self, v2: Vector) -> float:
    self.x * v2.x + self.y * v2.y + self.z * v2.z

  def mag(self) -> float:
    sqrt(self.x * self.x + self.y * self.y + self.z * self.z)

  def norm(self) -> Vector:
    self.times(1/self.mag())


def toByte(n: float) -> float:
 if n <= 0:
   0
 elif n >= 1:
   255
 else:
   int(n * 255)


class Color:
  let r: float
  let g: float
  let b: float

  def scale(self, k: float) -> Color:
    Color(k * self.r, k * self.g, k * self.b)

  def plus(self, c2: Color) -> Color:
    Color(self.r + c2.r, self.g + c2.g, self.b + c2.b)

  def times(self, c2: Color) -> Color:
    Color(self.r * c2.r, self.g * c2.g, self.b * c2.b)

  def toDrawingColor(self) -> float:
    255*256*65536 + toByte(self.r) * 65536 + toByte(self.g) * 256 + toByte(self.b)


let BLACK = Color(0,0,0)
let WHITE = Color(1,1,1)
let GREY = Color(0.5, 0.5, 0.5)


class Camera:
  let pos: Vector
  let forward: Vector
  let right: Vector
  let up: Vector

  def lookingAt(pos: Vector, lookAt: Vector) -> Camera:
    let down = Vector(0, -1, 0)
    let forward = lookAt.minus(pos).norm()
    let right = forward.cross(down).norm().times(1.5)
    let up = forward.cross(right).norm().times(1.5)
    Camera(pos, forward, right, up)


class Ray:
  let start: Vector
  let dir: Vector


class Intersection:
  let thing: Thing
  let ray: Ray
  let dist: float


trait Surface:
  def roughness(self) -> float
  def diffuse(self, pos: Vector) -> Color
  def specular(self, pos: Vector) ->  Color
  def reflect(self, pos: Vector) -> float


trait Thing:
  def surface(self) -> Surface
  def normal(self, pos: Vector) -> Vector
  def intersect(self, ray: Ray) -> Intersection

class Light:
  let pos: Vector
  let color: Color

class Scene:
  let things: List[Thing]
  let lights: List[Light]
  let camera: Camera
  let background: Color

class Sphere:
  let center: Vector
  let radius2: float
  let surface: Surface

  def create(center: Vector, radius: float, surface: Surface) -> Sphere:
    Sphere(center, radius * radius, surface)


impl Thing for Sphere:

 def surface(self) -> Surface:
   self.surface

 def normal(self, pos: Vector) -> Vector:
   pos.minus(self.center).norm()

 def intersect(self, r: Ray) -> Intersection:
   let eo = self.center.minus(r.start)
   let v = eo.dot(r.dir)
   var dist = 1/0
   if v >= 0 :
     let disc = self.radius2 - (eo.dot(eo) - v * v)
     if disc >= 0 :
       dist = v - sqrt(disc)

  Intersection(self, r, dist)


class Plane:
  let norm: Vector
  let offset: float
  let surface: Surface


impl Thing for Plane:
  def surface(self) -> Surface:
    self.surface

  def normal(self, pos: Vector) -> Vector:
    self.norm

  def intersect(self, r: Ray) -> Intersection:
    let denom = self.norm.dot(r.dir)
    var dist = 1/0
    if denom <= 0:
      dist = (self.norm.dot(r.start) + self.offset) / (-denom)

    Intersection.new(self, r, dist)


class Shiny:

impl Surface for Shiny:
  def roughness(self) -> float:
    250

  def diffuse(self, pos: Vector) -> Color:
    WHITE

  def specular(self, pos: Vector) -> Color:
    GREY

  def reflect(self, pos: Vector) -> float:
    0.7

class Checkerboard:

impl Surface for Checkerboard:
  def roughness(self) -> float:
    150

  def diffuse(self, pos: Vector) -> Color:
    if (100000 + floor(pos.z) + floor(pos.x)) % 2 != 0 :
      Color.WHITE
    else:
      Color.BLACK

 def specular(self, pos: Vector) -> Color:
   Color.WHITE

 def reflect(self, pos: Vector) -> float:
   if (1000 + int(pos.z) + int(pos.x)) % 2 != 0 :
     0.1
   else:
     0.7


class RayTracer:
  let maxDepth = 5
  let defaultColor = BLACK

  def intersections(self, r: Ray, s: Scene) -> Intersection:
    var closest = s.things[0].intersect(r)
    for i in range(1, s.things.size):
      let inter = s.things[i].intersect(r)
      if inter.dist < closest.dist :
        closest = inter

    closest

  def testRay(self, r: Ray, s: Scene) -> float:
    self.intersections(r, s).dist

  def traceRay(self, r: Ray, s: Scene, depth: float) -> Color:
    let isect = self.intersections(r, s)
    if isect.dist == 1/0 :
      s.background
    else:
      self.shade(isect, s, depth)

  def shade(self, isect: Intersection, s: Scene, depth: float) -> Color:
    let d = isect.ray.dir
    let pos = d.times(isect.dist).plus(isect.ray.start)
    let normal = isect.thing.normal(pos)
    let reflectDir = d.minus(normal.times(2 * normal.dot(d)))
    let naturalColor = s.background.plus(self.getNaturalColor(isect.thing, pos, normal, reflectDir, s))
    var reflectedColor = Color.GREY
    if depth < self.maxDepth :
      reflectedColor = self.getReflectionColor(isect.thing, pos, normal, reflectDir, s, depth)

    naturalColor.plus(reflectedColor)

  def getReflectionColor(self, t: Thing, pos: Vector, normal: Vector, rd: Vector, s: Scene, depth: float) -> Color:
    self.traceRay(Ray.new(pos, rd), s, depth + 1).scale(t.surface().reflect(pos))

  def addLight(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene, col: Color, l: Light) -> Color:
    let ldis = l.pos.minus(pos)
    let livec = ldis.norm()
    let nearIsect = self.testRay(Ray.new(pos, livec), s)
    let isInShadow = (nearIsect <= ldis.mag())
    if isInShadow :
      return col

    let illum = livec.dot(norm)
    var lcolor = self.defaultColor
    if illum > 0 :
      lcolor = l.color.scale(illum)

    let specular = livec.dot(rd.norm())
    var scolor = self.defaultColor
    if specular > 0 :
      scolor = l.color.scale(specular ^ t.surface().roughness())

    let surf = t.surface()
    let diff = surf.diffuse(pos)
    col.plus(lcolor.times(diff)).plus(scolor.times(t.surface().specular(pos)))

  def getNaturalColor(self, t: Thing, pos: Vector, norm: Vector, rd: Vector, s: Scene) -> Color:
    var col = self.defaultColor
    for l in s.lights:
      col = self.addLight(t, pos, norm, rd, s, col, l)

    col

  def getPoint(self, x: float, y: float, cam: Camera) -> Vector:
    cam.forward.plus(cam.right.times(x / 200)).plus(cam.up.times(y / 200)).norm()

  def render(self, s: Scene, p: Pen, screenWidth: float, screenHeight: float):
    p.strokeColor = 0
    for y in range(screenHeight):
      for x in range(-screenWidth / 2, screenWidth / 2):
        var yy = floor(y / 2)
        if y % 2 == 0:
          yy = -yy

        let color = self.traceRay(Ray.new(s.camera.pos, self.getPoint(x, yy, s.camera)), s, 0)
        p.fillColor = color.toDrawingColor()
        p.rect(x, yy, 1.5, 1.5)



let defaultThings = [Plane(Vector(0,1,0), 0, Checkerboard()), Sphere(Vector(0,1,-0.25), 1, Shiny()), Sphere(Vector(-1,0.5,1.5),0.5, Shiny())]
let defaultLights = [Light(Vector(-2,2.5,0), Color(0.49,0.07,0.07)), Light(Vector(1.5,2.5,1.5), Color(0.07,0.07,0.49)), Light(Vector(1.5,2.5,-1.5), Color(0.07,0.49,0.071)), Light(Vector(0,3.5,0), Color(0.21,0.21,0.35))]
let defaultCamera = Camera(Vector(3,2,4), Vector(-1,0.5,0))
let defaultScene = Scene(BLACK, defaultThings, defaultLights, defaultCamera)

def main():
 let p = screen.newPen()
 let rayTracer = RayTracer()
 rayTracer.render(defaultScene, p, screen.width, screen.height)
